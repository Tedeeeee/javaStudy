## 프로세스와 쓰레드 ( `sec11` )

- 프로세스 
  - 각 프로그램을 실행하면 프로세스로 전환
  - 각각의 프로세스는 메모리 공간을 할당받는다
    - 코드, 데이터, Stack, Heap 공간을 받는다
    - 기본적으로 프로세스는 서로의 자원을 공유받지 않는다.
  - 생성시 비교적 많은 시간과 메모리를 소모한다
  - 종료시 프로그램 종료된다.
- 쓰레드
  - 한 프로세스 안에 여럿 생성되어 진행 될 수 있다.
    - 업데이트를 받으면서 코딩을 계속 하는 방법이다.
  - 프로세스 내의 자원을 여러 쓰레드가 공유하게 된다
    - 잘못 다루게 되면 굉장히 위험하다
  - 프로세스보다 생성 부담이 적다.

<br>

#### 쓰레드를 Java 코드로 만들기 ( `chap01 확인` )

- 쓰레드 구현 방법 2가지 
  1. Thread 클래스 상속
  2. Runnable 인터페이스를 구현하는 방법 
     - 이는 인터페이스의 유연함 덕분에 많이 사용하게 된다.
- 쓰레드는 run 과 start 로 사용 할 수 있는데 run 의 경우 main 쓰레드 안에서 그저 작동 될 뿐이다. 이는 쓰레드를 생성하는 이유가 사라지는 것이다. start 를 사용한다면 그 단점을 없앨 수 있다. 다만 결과가 실행 마다 다를 수 있다.
- sleep 메소드
  - Thread 의 정적 메소드이다
  - 주어진 밀리초 동안 해당 쓰레드를 멈춘다.
  - 예외 처리가 필요하다
  - 여러 개의 쓰레드를 만들고 해당 쓰레드를 잠들게 하고 싶다면 해당 쓰레드의 안에서 sleep 으로 잠재우는 것이다. 만들어져 있는 인스턴스에 sleep 을 건다면 main 메소드의 역할 쓰레드가 잠들어 버린다.

<br>

#### 쓰레드에 이름 부여하기 ( `chap02 확인` )
- Runnable 은 인터페이스로 SetName 을 가지고 있다. 이것을 인스턴스화 하여 setName 을 통해 이름을 정해면 currentThreadName 을 통해 이름을 확인할 수 있다.

<br>

#### 쓰레드 우선순위 주기 ( `chap02.Ex03 확인`)
- 쓰레드의 우선순위를 정해주는 것 또한 가능하다. 하지만 우선순위는 JVM 에서 할당해주기 때문에 실제로 일을 하는 OS 에게 참고 정도의 역할밖에 하지 못한다. 때문에 그냥 알아만 두는 것도 나쁘지않다.
- setPriority 를 통해 우선순위를 정해줄 수 있다
- yield() 를 통해 해당 쓰레드가 공동 우선순위인 쓰레드에게 양보가 가능하다
- 쓰레드를 이용하여 멀티 태스킹 하기

<br>

#### 쓰레드 그룹과 데몬 쓰레드 ( `chap03 확인`)
- 쓰레드 그룹
  - 연관된 쓰레드들을 그룹으로 묶기 위해 사용된다.
  - 쓰레드 그룹이 다른 쓰레드 그룹에 포함될 수 있다.
  - 쓰레드를 일괄적으로 다루거나 보안상 분리하기 위해 사용한다.
- 데몬 쓰레드
  - 다른 쓰레드의 작업을 보조해준다
  - 주 쓰레드의 작업이 끝나면 자동으로 종료한다.

<br>

#### 동기화 ( `chap04.ex02 확인`)
- 특정 자원에 여러 쓰레드가 동시에 접근하는 것을 방지한다
- synchronized 메소드 또는 블록을 사용한다. ( 하지만 이는 JVM 의 캐싱처리에 의한 문제가 발생할 수 있다.)
  - 해결책 1 . volatile 사용
  - 해결책 2 . 동기화 사용( Synchronized )

<br>

#### wait & notify ( `chap05 확인`)
- Object 의 쓰레드 관련 메소드들
  - wait : 동기화 메소드 사용 중 자기 일을 멈춘다.
    - 다른 쓰레드가 사용할 수 있도록 양보한다
  - notify : 일을 멈춘 상태의 쓰레드에게 자리가 비었다는 것을 알린다.
    - 대기열의 쓰레드 중 하나에만 통보한다.
    - 상황에 따라 무한 대기를 할 수도 있다.
  - notifyAll : 대기중인 모든 쓰레드에 통보한다
    - 모든 쓰레드에게 통보하기 때문에 통산 해당 메소드를 많이 사용한다.

<br>

#### 쓰레드 풀과 Future ( `chap06 확인`)
- 쓰레드 풀
- Executors & ExecutorService 를 사용해서 구현한다.
  - java.util.concurrent 패키지에서 제공하는 것이다.
- 많은 쓰레드 작업이 필요할 때 동시에 돌아가는 쓰레드들의 갯수를 제한한다.
  - 너무 많은 쓰레드 작업으로 인한 부하를 방지하는 이유이다.
- 쓰레드를 그때그때 생성하고 제거하지 않는다
  - 만들어진 만큼만 사용하고 재사용한다.
- 개발자가 직접해주는 경우는 드물다
  - Runnable 을 대기열에 추가하면 자리가 나는대로 태워보낸다.
  - 쓰레드들을 쓰레드 풀이 알아서 관리한다.


