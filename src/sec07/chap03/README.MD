# Generic 공부 ( Main.java 확인)

- 자료형을 필요에 따라 동적으로 정할 수 있도록 해주는것
  - 자료형의 변수로 갖는다고 이해하면 편하다
- 메소드 또는 클래스에서 사용한다.
  - 어떤 메소드를 만들때 정확히 어떤 타입의 값이 들어올지 모른다. 원시형과 참조 타입은 물론 사용자가 만든 클래스까지 말이다.
  - 제네릭은 이를 모두 포용할 수 있게 만들어주는 것이다. 한계를 깨준다는 정도?

<br>

1. ex01
- 반환값과 인자값은 같아야한다. 인자의 타입이 무엇이 들어오는 것보다 반환값과 같아야하는 것이 중요하다

<br>

2. ex02
- 클래스에 < >를 통해 다양한 타입을 받는다고 표시하고 인스턴스를 생성할 때 생성자에 다양한 참조형을 받을 수도 있다
- 인스턴스를 생성할때도 타입을 적어주어야 하지만 타입 추론이 가능하다.

<br>

3. ex03
- 우리가 만드는 클래스에 다양한 타입을 받게 되지만 때에 따라 받고 싶은 타입이 정해져있을수 있다. 그땐 extends 를 사용할 수 있다.
  - 예를 들어 숫자 타입(Number)만 받고 싶다면 extends Number 를 통해 숫자 타입의 값만 받으면서 문자, 제작된 클래스 타입은 받지 않게 되는것이다.
- 인터페이스를 상속할 수도 있다
  - 제네릭은 인터페이스를 상속할 때도 extends 를 사용하고 갯수가 여러개라면 &를 통해 연결한다
  - 당연하지만 상속받은 인터페이스를 implements 한 클래스만 받을 수 있다.

<br>

4. ex04
   1. FormElement 를 통해 현재 어떤 Mode인지 확인하고 func() 라는 추상 메소드를 작성
   2. Clickable 이라는 인터페이스를 만들어 버튼을 클릭하는 추상 메소드 작성
   3. Button 클래스에 두개를 상속받아 버튼을 클릭하는 행위를 작성해주었다.
   4. Switch 클래스도 마찬가지로 만들어주는데 여기선 true(켜기) 와 false(끄기)라는 필드도 주었다.
   5. TextInput 클래스는 모드 확인이 필요없기에 클릭하는 인터페이스만 상속
   6. FormElement 와 Clickable 이라는 두 개를 타입으로 상속받는 FormClicker 를 만들어준다
      - 두개의 능력을 모두 사용할 수 있다. 때문에 현재 Mode 를 출력하는 printElemMode 와  onClick() 를 구현한 내용을 볼 수 있다.
      - 이 클래스를 만들어 모드와 클릭 상황을 모두 볼 수 있게 할 수 있다.
   7. Main 에서 확인해보기

<br>

5. ex05 ( 제네릭의 와일드 카드 )
- 부모는 자식을 품을 수 있어도 자식은 부모를 품을 수 없다. `( Main 확인 )`
- ? (제네릭의 와일드 카드) - extends 와 super 가 있다.
  - extends : 아무것도 안적은 것과 똑같다 자기자신과 본인의 자식만 가능하다
  - super : 자기자신과 부모(조상)이 가능하다.
- 제네릭은 변수에 들어오는 값을 제한하는 것이지 데이터에 대한 반항을 하는 것이 아니다. `( Main 마지막 반복문 )`
  - 때문에 Unit 자체를 상속하고 있는 Horse 의 타입은 Unit 으로 모두 받는다. 





